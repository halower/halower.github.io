<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>springboot瘦身</title>
    <url>/2020/10/30/springboot%E7%98%A6%E8%BA%AB/</url>
    <content><![CDATA[<blockquote>
<p>鉴于网上很多代码都是同一篇文章转载过来的基本验证无效，以下是经过项目测试后可用的方案</p>
</blockquote>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">jar.doFirst &#123;</span><br><span class="line">    manifest &#123;</span><br><span class="line">        attributes <span class="string">&#x27;Class-Path&#x27;</span>: configurations.compileClasspath.files.collect &#123; <span class="string">&quot;lib&quot;</span>+File.separator+<span class="string">&quot;$it.name&quot;</span> &#125;.join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        attributes <span class="string">&#x27;Main-Class&#x27;</span>:  <span class="string">&#x27;com.halower.dynamicdb.DynamicDatasourceLab&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task thinJar(<span class="attr">type:</span> Copy) &#123;</span><br><span class="line">    <span class="keyword">def</span> dir = <span class="keyword">new</span> File( <span class="string">&quot;$buildDir&quot;</span>+File.separator+<span class="string">&quot;libs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!dir.exists()) dir.mkdir()</span><br><span class="line">    dir.eachDir&#123;d -&gt; d.delete()&#125;</span><br><span class="line">    from configurations.compileClasspath</span><br><span class="line">    into <span class="string">&quot;$buildDir&quot;</span>+File.separator+<span class="string">&quot;libs&quot;</span>+File.separator+<span class="string">&quot;lib&quot;</span></span><br><span class="line">    print(<span class="string">&#x27;依赖包提取完成&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jar.enabled = <span class="literal">true</span></span><br><span class="line">bootJar.enabled = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bootJar &#123;</span><br><span class="line">    dependsOn thinJar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
        <category>gradle</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper伪集群部署</title>
    <url>/2020/11/14/zookeeper%E4%BC%AA%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><blockquote>
<h2 id="国内：【-https-mirrors-cloud-tencent-com】"><a href="#国内：【-https-mirrors-cloud-tencent-com】" class="headerlink" title="国内：【 https://mirrors.cloud.tencent.com】"></a>国内：【 <a href="https://mirrors.cloud.tencent.com】/">https://mirrors.cloud.tencent.com】</a></h2></blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.cloud.tencent.com/apache/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2-bin.tar.gz</span><br></pre></td></tr></table></figure>
<h2 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/zookeeper</span><br><span class="line">cd /opt/zookeeper </span><br><span class="line">tar -zxvf  /opt/zookeeper-3.6.2.tar.gz </span><br><span class="line">cp -rf /opt/zookeeper/zookeeper-3.6.2   /opt/zookeeper/zoo-node1</span><br><span class="line">cp -rf /opt/zookeeper/zookeeper-3.6.2   /opt/zookeeper/zoo-node2</span><br><span class="line">cp -rf /opt/zookeeper/zookeeper-3.6.2   /opt/zookeeper/zoo-node3</span><br><span class="line">rm -rf  /opt/zookeeper/zookeeper-3.6.2 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样，zookeeper的三个节点运行目录分别为：</span></span><br><span class="line"> /opt/zookeeper/zoo-node1</span><br><span class="line"> /opt/zookeeper/zoo-node2</span><br><span class="line"> /opt/zookeeper/zoo-node3</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="zoo-cfg配置文件"><a href="#zoo-cfg配置文件" class="headerlink" title="zoo.cfg配置文件"></a>zoo.cfg配置文件</h3><p>zookeeper的运行，需要在conf目录配置zoo.cfg文件。我们可以参考zoo_sample.cfg进行配置。</p>
<p>节点1配置如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#zookeeper时间单元，单位为毫秒</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment">#集群中的follower服务器(F)与leader服务器(L)之间 初始连接 时能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 集群中的follower服务器(F)与leader服务器(L)之间 请求和应答 之间能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># data数据目录</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">/opt/zookeeper/zoo-node1/data</span></span><br><span class="line"><span class="comment"># 客户端连接端口</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"><span class="comment"># 客户端最大连接数</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment"># 需要保留的快照数目</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># 是否开启自动清理事务日志和快照功能 0 不开启，1表示开启</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"><span class="comment">#集群配置 </span></span><br><span class="line"><span class="meta">server.1</span>=<span class="string">127.0.0.1:2888:3888</span></span><br><span class="line"><span class="meta">server.2</span>=<span class="string">127.0.0.1:2889:3889</span></span><br><span class="line"><span class="meta">server.3</span>=<span class="string">127.0.0.1:2890:3890</span></span><br></pre></td></tr></table></figure>

<p>节点2配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#zookeeper时间单元，单位为毫秒</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment">#集群中的follower服务器(F)与leader服务器(L)之间 初始连接 时能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 集群中的follower服务器(F)与leader服务器(L)之间 请求和应答 之间能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># data数据目录</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">/opt/zookeeper/zoo-node2/data</span></span><br><span class="line"><span class="comment"># 客户端连接端口</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2182</span></span><br><span class="line"><span class="comment"># 客户端最大连接数</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment"># 需要保留的快照数目</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># 是否开启自动清理事务日志和快照功能 0 不开启，1表示开启</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"><span class="comment">#集群配置 </span></span><br><span class="line"><span class="meta">server.1</span>=<span class="string">127.0.0.1:2888:3888</span></span><br><span class="line"><span class="meta">server.2</span>=<span class="string">127.0.0.1:2889:3889</span></span><br><span class="line"><span class="meta">server.3</span>=<span class="string">127.0.0.1:2890:3890</span></span><br></pre></td></tr></table></figure>

<p>节点3配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#zookeeper时间单元，单位为毫秒</span></span><br><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment">#集群中的follower服务器(F)与leader服务器(L)之间 初始连接 时能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">10</span></span><br><span class="line"><span class="comment"># 集群中的follower服务器(F)与leader服务器(L)之间 请求和应答 之间能容忍的最多心跳数（tickTime的数量）。</span></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">5</span></span><br><span class="line"><span class="comment"># data数据目录</span></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">/opt/zookeeper/zoo-node3/data</span></span><br><span class="line"><span class="comment"># 客户端连接端口</span></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2183</span></span><br><span class="line"><span class="comment"># 客户端最大连接数</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment"># 需要保留的快照数目</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># 是否开启自动清理事务日志和快照功能 0 不开启，1表示开启</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"><span class="comment">#集群配置 </span></span><br><span class="line"><span class="meta">server.1</span>=<span class="string">127.0.0.1:2888:3888</span></span><br><span class="line"><span class="meta">server.2</span>=<span class="string">127.0.0.1:2889:3889</span></span><br><span class="line"><span class="meta">server.3</span>=<span class="string">127.0.0.1:2890:3890</span></span><br></pre></td></tr></table></figure>

<p>分别将上述配置文件放置在三个节点对应的conf目录下。另外，需要新建data目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /opt/zookeeper/zoo-node1/data</span><br><span class="line">mkdir /opt/zookeeper/zoo-node2/data</span><br><span class="line">mkdir /opt/zookeeper/zoo-node3/data</span><br></pre></td></tr></table></figure>

<h3 id="myid配置文件"><a href="#myid配置文件" class="headerlink" title="myid配置文件"></a>myid配置文件</h3><p>zookeeper还需要在data目录中配置myid文件。myid文件中存放对应节点的序号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;1&#x27;</span>  &gt;  /opt/zookeeper/zoo-node1/data/myid</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;2&#x27;</span>  &gt;  /opt/zookeeper/zoo-node2/data/myid</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;3&#x27;</span>  &gt;  /opt/zookeeper/zoo-node3/data/myid</span><br></pre></td></tr></table></figure>

<h3 id="日志路径配置"><a href="#日志路径配置" class="headerlink" title="日志路径配置"></a>日志路径配置</h3><p>修改 bin 目录下的zkEnv.sh<br>将ZOO_LOG_DIR 修改为：<code>ZOO_LOG_DIR=&quot;../logs/&quot;</code></p>
<p>按上述方法分别修改三个节点中的zkEnv.sh文件</p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/zookeeper/zoo-node1/bin/zkServer.sh start</span><br><span class="line">/opt/zookeeper/zoo-node2/bin/zkServer.sh start</span><br><span class="line">/opt/zookeeper/zoo-node2/bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>如此分别启动三个节点即可。<br>启动效果如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost bin</span>]<span class="meta"># /opt/zookeeper/zoo-node1/bin/zkServer.sh start</span></span><br><span class="line">ZooKeeper JMX enabled <span class="keyword">by</span> <span class="literal">default</span></span><br><span class="line">Using config: /opt/zookeeper/zoo-node1/bin/../conf/zoo.cfg</span><br><span class="line">Starting zookeeper ... STARTED</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程三大核心</title>
    <url>/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83/</url>
    <content><![CDATA[<p>「横看成岭侧成峰，远近高低各不同」，远看看轮廓，近看看细节，不断切换思维或视角来学习</p>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83/202010240002-1603524670758.jpg" class="">

<p><strong>并发编程可以抽象成三个核心问题: 分工、同步/协作、互斥</strong></p>
<p>如果你已经工作了，那么你一定听说过或者正在应用敏捷开发模式来交付日常的工作任务，我们就用你熟悉的流程来解释这三个核心问题</p>
<h2 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h2><blockquote>
<p>将当前 Sprint 的 Story 拆分成「合适」大小的 Task，并且安排给「合适」的 Team Member 去完成</p>
</blockquote>
<p>这里面用了两个「合适」，将 Story 拆分成大小适中，可完成的 Task 是非常重要的。拆分的粒度太粗，导致这个任务完成难度变高，耗时长，不易与其他人配合；拆分的粒度太细，又导致任务太多，不好管理与追踪，浪费精力和资源。(<strong>合适的线程才能更好的完成整块工作，当然一个线程可以轻松搞定的就没必要多线程</strong>)；安排给合适的人员去完成同样重要，<code>UX-UE</code> 问题交给后端人员处理，很显然是有问题的 (<strong>主线程应该做的事交给子线程显然是解决不了问题的，每个线程做正确的事才能发挥作用</strong>)</p>
<p>关于分工，常见的 Executor，生产者-消费者模式，Fork/Join 等，这都是分工思想的体现</p>
<h2 id="同步-协作"><a href="#同步-协作" class="headerlink" title="同步/协作"></a>同步/协作</h2><p>任务拆分完毕，我要等张三的任务，张三要等李四的任务，也就是说任务之间存在依赖关系，前面的任务执行完毕，后面的任务才可以执行，人高级在可以通过沟通反复确认，确保自己的任务可以开始执行。<strong>但面对程序，我们需要了解程序的沟通方式，一个线程执行完任务，如何通知后续线程执行</strong></p>
<p>所有的同步/协作关系我们都可以用你最熟悉的 If-then-else 来表示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(前序任务完成)&#123;</span><br><span class="line">    execute();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是说:<strong>当某个条件不满足时，线程需要等待；当某个条件满足时，线程需要被唤醒执行</strong>，线程之间的协作可能是主线程与子线程的协作，可能是子线程与子线程的合作， <code>Java SDK </code>中<code> CountDownLatch</code> 和 <code>CyclicBarrier</code> 就是用来解决线程协作问题的</p>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p><strong>分工和同步强调的是性能，但是互斥是强调正确性</strong>，就是我们常常提到的「线程安全」，当多个线程<strong>同时</strong>访问一个共享变量/成员变量时，就可能发生不确定性，造成不确定性主要是有<code>可见性</code>、<code>原子性</code>、<code>有序性</code>这三大问题，而解决这些问题的核心就是互斥</p>
<blockquote>
<h3 id="互斥-1"><a href="#互斥-1" class="headerlink" title="互斥"></a>互斥</h3><p>同一时刻，只允许一个线程访问共享变量</p>
</blockquote>
<p>来看下图，主干路就是共享变量，进入主干路一次只能有一辆车，这样你是否理解了呢？「<strong>天下大事，分久必合</strong>」</p>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83/42f62cfa83224f5b8735bc03df7deb39.gif" class="" title="img">

<p>同样 <code>Java SDK </code>也有很多互斥的解决方案，比如你马上就能想到 <code>synchronized</code> 关键字，<code>Lock</code>，<code>ThreadLocal</code> 等就是互斥的解决方案</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>资本家疯狂榨取劳动工人的剩余价值，获得最大收益。当你面对 CPU，内存，IO 这些劳动工人时，你就是那个资本家，你要思考如何<code>充分榨取</code>它们的价值</p>
<blockquote>
<p>当一个工人能干的活，绝不让两个人来干(单线程能满足就没必要为了多线程)<br>当多个工人干活时，就要让他们分工明确，合作顺畅，没矛盾</p>
</blockquote>
<p>当任务很大时，由于 IO 干活慢，CPU 干活快，就没必要让 CPU 死等当前的 IO，转而去执行其他指令，这就是<code>榨取剩余价值</code>，如何最大限度的榨取其价值，这就涉及到后续的调优问题，比如多少线程合适等</p>
<p><strong>分工是设计，同步和互斥是实现</strong>，没有好的设计也就没有好的实现，所以在分工阶段，强烈建议大家勾划草图，了解瓶颈所在，这样才会有更好的实现，后续章节的内容，我也会带领大家画草图，分析问题，逐步养成这个习惯</p>
<p>本章内容可以用下面的图来简单概括，叶子结点的内容我们会逐步点亮，现阶段不用过分关注(如果你上来就啃 <code>JDK</code> 源码，也许你会痛苦的迷失，并最终放弃你的进阶之路的)</p>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83/202010240001.png" class="">

<p><strong>理解三大核心问题，你要充分结合生活中的实际，程序中的并发问题，基本上都能在实际生活中找得到原型</strong></p>
<p>下一篇文章的内容，我们就要聊聊，引起线程安全的三个问题:「可见性，原子性，有序性」，这涉及到 <code>JMM</code> 的一点内容，可以提前了解一下的，这样我们才能更好的碰撞</p>
<h2 id="灵魂追问"><a href="#灵魂追问" class="headerlink" title="灵魂追问"></a>灵魂追问</h2><ol>
<li>工作中多线程编程的场景多吗？</li>
<li>想到多线程，只会想到 synchronized 吗？</li>
<li>Java 并发包各个类，你有了解底层实现和设计理念吗？</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程三大问题</title>
    <url>/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<ul>
<li>生活中你一定听说过——能者多劳</li>
<li>作为 Java 程序员，你一定听过——这个功能请求慢，能加一层缓存或优化一下 SQL 吗？</li>
<li>看过中国古代神话故事的也一定听过——天上一天，地上一年</li>
</ul>
</blockquote>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/202010242008.png" class="">

<p>一切设计来源于生活，上一章 中有讲过，作为”资本家”，你要尽可能的榨取 CPU，内存与 IO 的剩余价值，但三者完成任务的速度相差很大，CPU &gt; 内存 &gt; IO，CPU 是天，那内存就是地，内存是天，那 IO 就是地，那怎样平衡三者，提升整体速度呢？</p>
<ol>
<li>CPU 增加缓存，还不止一层缓存，平衡内存的慢</li>
<li>CPU 能者多劳，通过分时复用，平衡 IO 的速度差异</li>
<li>优化编译指令</li>
</ol>
<p>上面的方式貌似解决了木桶短板问题，但同时这种解决方案也伴随着产生新的<strong>可见性，原子性，和有序性</strong>的问题，且看</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><strong>一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性</strong></p>
<p>谈到可见性，要先引出 JMM (Java Memory Model) 概念, 即 Java 内存模型，Java 内存模型规定，将所有的变量都存放在 <strong>主内存</strong> 中，当线程使用变量时，会把主内存里面的变量 <strong>复制</strong> 到自己的工作空间或者叫作 <strong>私有内存</strong> ，线程读写变量时操作的是自己工作内存中的变量。</p>
<p>用 Git 的工作流程理解上面的描述就很简单了，<strong>Git 远程仓库就是主内存，Git 本地仓库就是自己的工作内存</strong></p>
<p>文字描述有些抽象，我们来图解说明:</p>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/202010242001.png" class="">

<p>看这个场景:</p>
<blockquote>
<ol>
<li>主内存中有变量 x，初始值为 0</li>
<li>线程 A 要将 x 加 1，先将 x=0 拷贝到自己的私有内存中，然后更新 x 的值</li>
<li><strong>线程 A 将更新后的 x 值回刷到主内存的时间是不固定的</strong></li>
<li>刚好在线程 A 没有回刷 x 到主内存时，线程 B 同样从主内存中读取 x，此时为 0，和线程 A 一样的操作，最后期盼的 x=2 就会编程 x=1</li>
</ol>
</blockquote>
<p>这就是线程可见性的问题</p>
<p><code>JMM</code> 是一个抽象的概念，在实际实现中，线程的工作内存是这样的:</p>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/202010242002.jpg" class="">

<p>为了平衡内存/IO 短板，会在 CPU 上增加缓存，每个核都只有自己的一级缓存，甚至有一个所有 CPU 都共享的二级缓存，就是上图的样子了，都说这么设计是硬件同学留给软件同学的一个坑，但能否跳过去这个坑也是衡量软件同学是否走向 Java 进阶的关键指标吧……</p>
<blockquote>
<h4 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h4><p>从上图中你也可以看出，在 Java 中，所有的实例域，静态域和数组元素都存储在堆内存中，堆内存在线程之间共享，这些在后续文章中都称之为「共享变量」，局部变量，方法定义参数和异常处理器参数不会在线程之间共享，所以他们不会有内存可见性的问题，也就不受内存模型的影响</p>
</blockquote>
<p><strong>一句话，要想解决多线程可见性问题，所有线程都必须要刷取主内存中的变量</strong><br>怎么解决可见性问题呢？Java 关键字 <strong>volatile</strong> 帮你搞定，后续章节会分析……</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子（atom）指化学反应不可再分的基本微粒，原子性操作你应该能感受到其含义:</p>
<blockquote>
<p>所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch</p>
</blockquote>
<p>小品「钟点工」有一句非常经典的台词，要把大象装冰箱，总共分几步？</p>
<p>来看一小段程序:</p>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/202010242006.png" class="">

<p>多线程情况下能得到我们期盼的 <code>count = 20000</code> 的值吗？ 也许有同学会认为，线程调用的 counter 方法只有一个 count++ 操作，是单一操作，所以是原子性的，非也。在线程第一讲中说过我们不能用高级语言思维来理解 CPU 的处理方式，count++ 转换成 CPU 指令则需要三步，通过下面命令解析出汇编指令等信息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -c UnsafeCounter</span><br></pre></td></tr></table></figure>

<p>截取 counter 方法的汇编指令来看:</p>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/202010242005.png" class="">

<p>解释一下上面的指令，<br>16 : 获取当前 count 值，并且放入栈顶<br>19 : 将常量 1 放入栈顶<br>20 : 将当前栈顶中两个值相加，并把结果放入栈顶<br>21 : 把栈顶的结果再赋值给 count</p>
<p>由此可见，简单的 count++ 不是一步操作，被转换为汇编后就不具备原子性了，就好比大象装冰箱，其实要分三步:</p>
<blockquote>
<p>第一步，把冰箱门打开；第二步，把大象放进去；第三步，把冰箱门带上</p>
</blockquote>
<p>结合 <code>JMM</code> 结构图理解，说明一下为什么很难得到 <code>count=20000</code> 的结果:<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/202010242003.png" class=""></p>
<p>多线程计数器，如何保证多个操作的原子性呢？最粗暴的方式是在方法上加 <strong>synchronized</strong> 关键字，比如这样:</p>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/202010242006.png" class="">

<p>问题是解决了，如果 synchronized 是万能良方，那么也许并发就没那么多事了，可以靠一个 synchronized 走天下了，事实并不是这样，synchronized 是独占锁 (同一时间只能有一个线程可以调用)，没有获取锁的线程会被阻塞；另外也会带来很多线程切换的上下文开销</p>
<p>所以 <code>JDK</code> 中就有了非阻塞 CAS (Compare and <strong>Swap</strong>) 算法实现的原子操作类 AtomicLong 等工具类，看过源码的同学也许会发现一个共同特点，所有原子类中都有下面这样一段代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure>

<p>这个类是 JDK 的 rt.jar 包中的 Unsafe 类提供了 <strong>硬件级别</strong> 的原子性操作，类中的方法都是 native 修饰的，后面介绍原子类之前也会先说明这个类中的几个方法，这里先简单介绍有个印象即可。</p>
<p>有同学不理解我刚刚提到的线程上下文切换开销很大是什么意思，举 2个例子你就懂了:</p>
<blockquote>
<ul>
<li>你(CPU)在看两本书(两个线程)，看第一本书很短时间后要去看第二本书，看第二本书很短时间后又回看第一本书，并要精确的记得看到第几行，当初看到了什么(CPU 记住线程级别的信息)，当让你 <strong>“同时”</strong> 看 10 本甚至更多，切换的开销就很大了吧</li>
<li>综艺节目中有很多游戏，让你一边数钱，又要一边做其他的事，最终保证多样事情都做正确，大脑开销大不大，你试试就知道了😊</li>
</ul>
</blockquote>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>生活中你问候他人「吃了吗你？」和「你吃了吗？」是一个意思，你写的是下面程序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>；</span><br><span class="line">b =  <span class="number">2</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>

<p>编译器优化后可能就变成了这样:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">b =  <span class="number">2</span>;</span><br><span class="line">a = <span class="number">1</span>；</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>

<p>这个情况，编译器调整了语句顺序没什么影响，但编译器 <strong>擅自</strong> 优化顺序，就给我们埋下了雷，比如应用双重检查方式实现的单例</p>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/202010242004.png" class="">

<p>一切又很完美是不是，非也，问题出现在 <code>instance = new Singleton();</code>，这 1 行代码转换成了 CPU 指令后又变成了 3 个，我们理解 new 对象应该是这样的:</p>
<ol>
<li>分配一块内存 M</li>
<li>在内存 M 上初始化 Singleton 对象</li>
<li>然后 M 的地址赋值给 instance 变量</li>
</ol>
<p>但编译器<strong>擅自</strong>优化后可能就变成了这样:</p>
<ol>
<li>分配一块内存 M</li>
<li>然后将 M 的地址赋值给 instance 变量</li>
<li>在内存 M 上初始化 Singleton 对象</li>
</ol>
<p>首先 new 对象分了三步，给 CPU 留下了切换线程的机会；另外，编译器优化后的顺序可能导致问题的发生，来看:</p>
<blockquote>
<ol>
<li>线程 A 先执行 getInstance 方法，当执行到指令 2 时，恰好发生了线程切换</li>
<li>线程 B 刚进入到 getInstance 方法，判断 if 语句 instance 是否为空</li>
<li>线程 A 已经将 M 的地址赋值给了 instance 变量，所以线程 B 认为 instance 不为空</li>
<li>线程 B 直接 return instance 变量</li>
<li>CPU 切换回线程 A，线程 A 完成后续初始化内容</li>
</ol>
</blockquote>
<p>我们还是画个图说明一下:</p>
<img src="/2020/10/24/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98/202010242007-1603538900268.png" class="">

<p>如果线程 A 执行到第 2 步，线程切换，由于线程 A 没有把红色箭头执行完全，线程 B 就会得到一个未初始化完全的对象，访问 instance 成员变量的时候就可能发生 NPE，如果将变量 instance 用 volatile 或者 final 修饰(涉及到类的加载机制，问题就解决了.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>你所看到的程序并不一定是编译器优化/编译后的 CPU 指令，大象装冰箱是是个程序，但其隐含三个步骤，学习并发编程，你要按照 CPU 的思维考虑问题，所以你需要深刻理解 <strong>可见性/原子性/有序性</strong> ，这是产生并发 Bug 的源头</p>
<p>本节说明了三个问题，下面的文章也会逐个分析解决以上问题的办法，以及相对优的方案</p>
<h2 id="灵魂追问"><a href="#灵魂追问" class="headerlink" title="灵魂追问"></a>灵魂追问</h2><ol>
<li>为什么用 final 修饰的变量就是线程安全的了呢？</li>
<li>你会经常查看 CPU 汇编指令吗？</li>
<li>如果让你写单例，你通常会采用哪种实现？</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>有序性可见性，Happens-before来搞定</title>
    <url>/2020/10/24/%E6%9C%89%E5%BA%8F%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8CHappens-before%E6%9D%A5%E6%90%9E%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>上一篇文章谈到了<code>可见性/原子性/有序性</code>三个问题，这些问题通常违背我们的直觉和思考模式，也就导致了很多并发 Bug</p>
<ul>
<li>为了解决 CPU，内存，IO 的短板，增加了缓存，但这导致了可见性问题</li>
<li>编译器/处理器<code>擅自</code>优化 ( Java代码在编译后会变成 Java 字节码, 字节码被类加载器加载到 <code>JVM</code> 里, <code>JVM</code>执行字节码, 最终需要转化为汇编指令在 <code>CPU</code> 上执行) ，导致有序性问题</li>
</ul>
<p>初衷是好的，但引发了新问题，最有效的办法就禁止缓存和编译优化，问题虽然能解决，但「又回到最初的起点，呆呆地站在镜子前」是很尴尬的，我们程序的性能就堪忧了.</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>作为我们程序猿不想写出 bug 影响 KPI，所以希望内存模型易于理解、易于编程。这就需要基于一个<strong>强内存模型</strong>来编写代码</li>
<li>作为编译器和处理器不想让外人说它处理速度很慢，所以希望内存模型对他们束缚越少越好，可以由他们<strong>擅自优化</strong>，这就需要基于一个<strong>弱内存模型</strong></li>
</ol>
<blockquote>
<p>俗话说:「没有什么事是开会解决不了的，如果有，那就再开一次」😂</p>
</blockquote>
<p>JSR-133 的专家们就有了新想法，既然不能完全禁止缓存和编译优化，那就<strong>按需</strong>禁用缓存和编译优化，按需就是要加一些约束，约束中就包括了上一篇文章简单提到过的 <strong>volatile，synchronized，final</strong> 三个关键字，同时还有你可能听过的 <strong>Happens-Before</strong> 原则(包含可见性和有序性的约束)，Happens-before 规则也是本章的主要内容</p>
<p>为了满足二者的强烈需求，照顾到双方的情绪，于是乎: JMM 就对程序猿说了一个善意的谎言: 「会严格遵守 Happpen-Befores 规则，不会重排序」让程序猿放心，私下却有自己的策略:</p>
<ol>
<li>对于会改变程序执行结果的重排序,JMM要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序, JMM对编译器和处理器不做要求 (JMM允许这种重排序)。</li>
</ol>
<p>我们来用个图说明一下:</p>
<img src="/2020/10/24/%E6%9C%89%E5%BA%8F%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8CHappens-before%E6%9D%A5%E6%90%9E%E5%AE%9A/202010243001.png" class="">

<blockquote>
<p>这就是那个善意的谎言，虽是谎言，但还是照顾到了程序猿的利益，所以我们只需要了解 happens-before 规则就能得到保证 (图画了好久，不知道是否说明了谎言的所在😅，欢迎留言)</p>
</blockquote>
<h2 id="Happens-before"><a href="#Happens-before" class="headerlink" title="Happens-before"></a>Happens-before</h2><p>Happens-before 规则主要用来约束两个操作，两个操作之间具有 <code>happens-before</code> 关系, 并不意味着前一个操作必须要在后一个操作之前执行，<strong>happens-before 仅仅要求前一个操作(执行的结果)对后一个操作可见</strong>, (the first is <strong>visible</strong> to and ordered before the second)</p>
<p>说了这么多，先来看一小段代码带你逐步走进 Happen-Befores 原则，看看是怎样用该原则解决 <strong>可见性</strong> 和 <strong>有序性</strong> 的问题:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    x = <span class="number">42</span>;    <span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;    <span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123; <span class="comment">//3</span></span><br><span class="line">      System.out.println(x);    <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设 A 线程执行 writer 方法，B 线程执行 reader 方法，打印出来的 x 可能会是 0，上一篇文章说明过: 因为代码 1 和 2 没有<strong>数据依赖</strong>关系，所以可能被重排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flag = <span class="keyword">true</span>;    <span class="comment">//2</span></span><br><span class="line">x = <span class="number">42</span>;    <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>所以，线程 A 将 <code>flag = true</code> 写入<strong>但没有为 x 重新赋值时</strong>，线程 B 可能就已经打印了 x 是 0</p>
<p>那么为 flag 加上 volatile 关键字试一下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p><em>即便加上了 volatile 关键字，这个问题在 java1.5 之前还是没有解决，但 java1.5 和其之后的版本对 volatile 语义做了增强</em>，问题得以解决，这就离不开 Happens-before 规则的约束了，总共有 6 个规则，且看</p>
<h3 id="程序顺序性规则"><a href="#程序顺序性规则" class="headerlink" title="程序顺序性规则"></a>程序顺序性规则</h3><blockquote>
<p><strong>一个线程中</strong>的每个操作, happens-before 于该线程中的任意后续操作<br>第一感觉这个原则是一个在理想状态下的”废话”，并且和上面提到的会出现重排序的情况是矛盾的，注意这里是一个线程中的操作，其实隐含了「as-if-serial」语义: 说白了就是只要执行结果不被改变，无论怎么”排序”，都是对的</p>
</blockquote>
<p>这个规则是一个基础规则，happens-before 是多线程的规则，所以要和其他规则约束在一起才能体现出它的顺序性，别着急，继续向下看</p>
<h3 id="volatile变量规则"><a href="#volatile变量规则" class="headerlink" title="volatile变量规则"></a>volatile变量规则</h3><blockquote>
<p>对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读</p>
</blockquote>
<p>我将上面的程序添加两行代码作说明:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		x = <span class="number">42</span>;	<span class="comment">//1</span></span><br><span class="line">		y = <span class="number">50</span>;	<span class="comment">//2</span></span><br><span class="line">		flag = <span class="keyword">true</span>;	<span class="comment">//3</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag)&#123;	<span class="comment">//4</span></span><br><span class="line">			System.out.println(<span class="string">&quot;x:&quot;</span> + x);	<span class="comment">//5</span></span><br><span class="line">			System.out.println(<span class="string">&quot;y:&quot;</span> + y);	<span class="comment">//6</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到了 volatile 的内存增强语义，先来看个表格:</p>
<table>
<thead>
<tr>
<th>能否重排序</th>
<th>第二个操作</th>
<th>第二个操作</th>
<th>第二个操作</th>
</tr>
</thead>
<tbody><tr>
<td>第一个操作</td>
<td>普通读/写</td>
<td>volatile 读</td>
<td>volatile 写</td>
</tr>
<tr>
<td>普通读/写</td>
<td>-</td>
<td>-</td>
<td>NO</td>
</tr>
<tr>
<td>volatile 读</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>volatile 写</td>
<td>-</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<p>从这个表格 <strong>最后一列</strong> 可以看出:</p>
<blockquote>
<p>如果第二个操作为 volatile 写，不管第一个操作是什么，都不能重排序，<strong>这就确保了 volatile 写之前的操作不会被重排序到 volatile 写之后</strong><br>拿上面的代码来说，代码 1 和 2 不会被重排序到代码 3 的后面，但代码 1 和 2 可能被重排序 (没有依赖也不会影响到执行结果)，说到这里和 <strong>程序顺序性规则</strong>是不是就已经关联起来了呢？</p>
</blockquote>
<p>从这个表格的 <strong>倒数第二行</strong> 可以看出:</p>
<blockquote>
<p>如果第一个操作为 volatile 读，不管第二个操作是什么，都不能重排序，<strong>这确保了 volatile 读之后的操作不会被重排序到 volatile 读之前</strong><br>拿上面的代码来说，代码 4 是读取 volatile 变量，代码 5 和 6 不会被重排序到代码 4 之前</p>
</blockquote>
<p><em>volatile 内存语义的实现是应用到了 「内存屏障」，因为这完全够单独写一章的内容，这里为了不掩盖主角 Happens-before 的光环，保持理解 Happens-before 的连续性，先不做过多说明</em></p>
<p>到这里，看这个规则，貌似也没解决啥问题，因为它还要联合第三个规则才起作用</p>
<h3 id="传递性规则"><a href="#传递性规则" class="headerlink" title="传递性规则"></a>传递性规则</h3><blockquote>
<p>如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C<br>直接上图说明一下上面的例子</p>
<img src="/2020/10/24/%E6%9C%89%E5%BA%8F%E6%80%A7%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8CHappens-before%E6%9D%A5%E6%90%9E%E5%AE%9A/202010243002.png" class="">
</blockquote>
<p>从上图可以看出</p>
<ul>
<li><code>x =42</code> 和 <code>y = 50</code> Happens-before <code>flag = true</code>, 这是<strong>规则 1</strong></li>
<li>写变量(代码 3) <code>flag=true</code> Happens-before 读变量(代码 4) <code>if(flag)</code>，这是<strong>规则 2</strong></li>
</ul>
<p>根据<strong>规则 3</strong>传递性规则，<code>x =42</code> Happens-before 读变量 <code>if(flag)</code></p>
<blockquote>
<p><strong>谜案要揭晓了</strong>: 如果线程 B 读到了 flag 是 true，那么 <code>x =42</code> 和 <code>y = 50</code> 对线程 B 就一定可见了，这就是 Java1.5 的增强 (之前版本是可以普通变量写和 volatile 变量写的重排序的)</p>
</blockquote>
<p>通常上面三个规则是一种联合约束，到这里你懂了吗？规则还没完，继续看</p>
<h3 id="监视器锁规则"><a href="#监视器锁规则" class="headerlink" title="监视器锁规则"></a>监视器锁规则</h3><blockquote>
<p>对一个锁的解锁 happens-before 于随后对这个锁的加锁</p>
</blockquote>
<p>这个规则我觉得你应该最熟悉了，就是解释 synchronized 关键字的，来看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// 1.加锁</span></span><br><span class="line">		<span class="keyword">synchronized</span> (SynchronizedExample.class)&#123;</span><br><span class="line">			x = <span class="number">1</span>; <span class="comment">// 对x赋值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3.解锁</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.加锁</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		x = <span class="number">2</span>; <span class="comment">// 对x赋值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先获取锁的线程，对 x 赋值之后释放锁，另外一个再获取锁，一定能看到对 x 赋值的改动，就是这么简单，请小伙伴用下面命令查看上面程序，看同步块和同步方法被转换成汇编指令有何不同？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javap -c -v SynchronizedExample</span><br></pre></td></tr></table></figure>

<p>这和 synchronized 的语义相关，小伙伴可以先自行了解一下，锁的内容时会做详细说明</p>
<h3 id="start-规则"><a href="#start-规则" class="headerlink" title="start()规则"></a>start()规则</h3><blockquote>
<p>如果线程 A 执行操作 ThreadB.start() (启动线程B), 那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作，也就是说，主线程 A 启动子线程 B 后，子线程 B 能看到主线程在启动子线程 B 前的操作，看个程序就秒懂了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StartExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		StartExample startExample = <span class="keyword">new</span> StartExample();</span><br><span class="line"></span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(startExample::writer, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">		startExample.x = <span class="number">10</span>;</span><br><span class="line">		startExample.y = <span class="number">20</span>;</span><br><span class="line">		startExample.flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">		thread1.start();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;x:&quot;</span> + x );</span><br><span class="line">		System.out.println(<span class="string">&quot;y:&quot;</span> + y );</span><br><span class="line">		System.out.println(<span class="string">&quot;flag:&quot;</span> + flag );</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">主线程结束</span><br><span class="line">x:<span class="number">10</span></span><br><span class="line">y:<span class="number">20</span></span><br><span class="line">flag:<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>线程 1 看到了主线程调用 thread1.start() 之前的所有赋值结果，这里没有打印「主线程结束」，你知道为什么吗？这个守护线程知识有关系</p>
<h3 id="join-规则"><a href="#join-规则" class="headerlink" title="join()规则"></a>join()规则</h3><blockquote>
<p>如果线程 A 执行操作 ThreadB.join() 并成功返回, 那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回，<strong>和 start 规则刚好相反</strong>，主线程 A 等待子线程 B 完成，当子线程 B 完成后，主线程能够看到子线程 B 的赋值操作，将程序做个小改动，你也会秒懂的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		JoinExample joinExample = <span class="keyword">new</span> JoinExample();</span><br><span class="line"></span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(joinExample::writer, <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">		thread1.start();</span><br><span class="line"></span><br><span class="line">		thread1.join();</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;x:&quot;</span> + joinExample.x );</span><br><span class="line">		System.out.println(<span class="string">&quot;y:&quot;</span> + joinExample.y );</span><br><span class="line">		System.out.println(<span class="string">&quot;flag:&quot;</span> + joinExample.flag );</span><br><span class="line">		System.out.println(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.x = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">this</span>.y = <span class="number">200</span>;</span><br><span class="line">		<span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">复制x:<span class="number">100</span></span><br><span class="line">y:<span class="number">200</span></span><br><span class="line">flag:<span class="keyword">true</span></span><br><span class="line">主线程结束</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>「主线程结束」这几个字打印出来喽，依旧和线程何时退出有关系</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>Happens-before 重点是解决前一个操作结果对后一个操作可见</strong>，相信到这里，你已经对 Happens-before 规则有所了解，这些规则解决了多线程编程的可见性与有序性问题，但还没有完全解决原子性问题(除了 synchronized)</li>
<li>start 和 join 规则也是解决主线程与子线程通信的方式之一</li>
<li>从内存语义的角度来说, volatile 的<code>写-读</code>与锁的<code>释放-获取</code>有相同的内存效果；volatile 写和锁的释放有相同的内存语义; volatile 读与锁的获取有相同的内存语义，⚠️⚠️⚠️(敲黑板了) volatile 解决的是可见性问题，synchronized 解决的是原子性问题，这绝对不是一回事，后续文章也会说明</li>
</ol>
<h2 id="灵魂追问"><a href="#灵魂追问" class="headerlink" title="灵魂追问"></a>灵魂追问</h2><ol>
<li>同步块和同步方法在编译成 CPU 指令后有什么不同？</li>
<li>线程有 Daemon(守护线程)和非 Daemon 线程，你知道线程的退出策略吗？</li>
<li>关于 Happens-before 你还有哪些疑惑呢？</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>解决原子性问题？你首先需要的是宏观理解</title>
    <url>/2020/10/24/%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E7%9A%84%E6%98%AF%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>上一篇文章 <strong>可见性有序性，Happens-before来搞定</strong>，解决了并发三大问题中的两个，今天我们就聊聊如何解决原子性问题</p>
<p><img src="/_posts/%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E7%9A%84%E6%98%AF%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3/202010243001.png" alt="img"></p>
<p>原子性问题的源头就是 <strong>线程切换</strong>，但在多核 CPU 的大背景下，不允许线程切换是不可能的，正所谓「魔高一尺，道高一丈」，新规矩来了:</p>
<blockquote>
<p>互斥: 同一时刻只有一个线程执行</p>
</blockquote>
<p>实际上，上面这句话的意思是: 对共享变量的修改是互斥的，也就是说线程 A 修改共享变量时其他线程不能修改，这就不存在操作被打断的问题了，那么如何实现互斥呢？</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>对并发有所了解的小伙伴马上就能想到 <strong>锁</strong> 这个概念，并且你的第一反应很可能就是使用 synchronized，这里列出来你常见的 synchronized 的三种用法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">normalSyncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//临界区</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticSyncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//临界区</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlockMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">			<span class="comment">//临界区</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三种 synchronized 锁的内容有一些差别:</p>
<ul>
<li>对于普通同步方法，锁的是当前实例对象，通常指 this</li>
<li>对于静态同步方法，锁的是当前类的 Class 对象，如 ThreeSync.class</li>
<li>对于同步方法块，锁的是 synchronized 括号内的对象</li>
</ul>
<p>我特意在三种 synchronized 代码里面添加了「临界区」字样的注释，那什么是临界区呢？</p>
<blockquote>
<p>临界区: 我们把需要互斥执行的代码看成为临界区</p>
</blockquote>
<p>说到这里，和大家串的知识都是表层认知，<strong>如何用锁保护有效的临界区才是关键</strong>，这直接关系到你是否会写出并发的 bug，了解过本章内容后，你会发现无论是隐式锁/内置锁 (synchronized) 还是显示锁 (Lock) 的使用都是在找寻这种关系，关系对了，一切就对了，且看</p>
<p>上面锁的三种方式都可以用下图来表达:</p>
<p><img src="/_posts/%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E7%9A%84%E6%98%AF%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3/202010244002.png"></p>
<p>线程进入临界区之前，尝试加锁 lock()， 加锁成功，则进入临界区(对共享变量进行修改)，持有锁的线程执行完临界区代码后，执行 unlock()，释放锁。针对这个模型，大家经常用抢占厕所坑位来形容:</p>
<p><img src="/_posts/%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E7%9A%84%E6%98%AF%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3/202010244003.png"></p>
<p>在学习 Java 早期我就是这样记忆与理解锁的，但落实到代码上，我们很容易忽略两点:</p>
<ol>
<li>我们锁的是什么？</li>
<li>我们保护的又是什么？</li>
</ol>
<p>将这两句话联合起来就是你的锁能否对临界区的资源起到保护的作用？所以我们要将上面的模型进一步细化<img src="/_posts/%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E7%9A%84%E6%98%AF%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3/202010244004.png"></p>
<p>现实中，<strong>我们都知道自己的锁来锁自己需要保护的东西</strong> ，这句话翻译成你的行动语言之后你已经明确知道了:</p>
<ol>
<li>你锁的是什么</li>
<li>你保护的资源是什么</li>
</ol>
<p>CPU 可不像我们大脑这么智能，我们要明确说明我们锁的是什么，我们要保护的资源是什么，它才会用锁保护我们想要保护的资源(共享变量)</p>
<p>拿上图来说，资源 R (共享变量) 就是我们要保护的资源，所以我们就要创建资源 R 的锁来保护资源 R，细心的朋友可能发现上图几个问题:</p>
<blockquote>
<p>LR 和 R 之间有明确的指向关系<br>我们编写程序时，往往脑子中的模型是对的，但是忽略了这个指向关系，导致自己的锁不能起到保护资源 R 的作用(用别人家的锁保护自己家的东西或用自己家的锁保护别人家的东西)，最终引发并发 bug，<strong>所以在你勾画草图时，要明确找到这个关系</strong></p>
</blockquote>
<blockquote>
<p>左图 LR 虚线指向了非共享变量<br>我们写程序的时候很容易这么做，不确定哪个是要保护的资源，直接大杂烩，用 LR 将要保护的资源 R 和没必要保护的非共享变量一起保护起来了，举两个例子来说你就明白这么做的坏处了</p>
</blockquote>
<ol>
<li>编写串行程序时，是不建议 try…catch 整个方法的，这样如果出现问是很难定位的，道理一样，我们要用锁精确的锁住我们要保护的资源就够了，其他无意义的资源是不要锁的</li>
<li>锁保护的东西越多，临界区就越大，一个线程从走入临界区到走出临界区的时间就越长，这就让其他线程等待的时间越久，这样并发的效率就有所下降，其实这是涉及到锁粒度的问题，后续也都会做相关说明</li>
</ol>
<p>作为程序猿还是简单拿代码说明一下心里比较踏实，且看:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">badSync</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//其他与共享变量count无关的业务逻辑</span></span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goodSync</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//其他与共享变量count无关的业务逻辑</span></span><br><span class="line">		<span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这里并不是说 synchronized 放在方法上不好，只是提醒大家用合适的锁的粒度才会更高效</em></p>
<p>在计数器程序例子中，我们会经常这么写:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">counter</span><span class="params">()</span></span>&#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图就是上面程序的模型展示:</p>
<p><img src="/_posts/%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E7%9A%84%E6%98%AF%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3/202010244005.png"></p>
<p>这里我们锁的是 this，可以保护 this.count。但有些同学认为 getCount 方法没必要加 synchronized 关键字，因为是读的操作，不会对共享变量做修改，如果不加上 synchronized 关键字，就违背了我们上一篇文章 happens-before 规则中的监视器锁规则:</p>
<p>对一个锁的解锁 happens-before 于随后对这个锁的加锁<br>也就是说对 count 的写很可能对 count 的读不可见，也就导致脏读</p>
<p>上面我们看到一个 this 锁是可以保护多个资源的，那用多个不同的锁保护一个资源可以吗？来看一段程序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">counter</span><span class="params">()</span></span>&#123;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>睁大眼睛仔细看，一个锁的是 this，一个锁的是 UnsafeCounter.class, 他们都想保护共享变量 count，你觉得如何？下图就是行面程序的模型展示:</p>
<p><img src="/_posts/%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F%E4%BD%A0%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E7%9A%84%E6%98%AF%E5%AE%8F%E8%A7%82%E7%90%86%E8%A7%A3/202010244006.png"></p>
<p>两个临界区是用两个不同的锁来保护的，所以临界区没有互斥关系，也就不能保护 count，所以这样加锁是无意义的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>解决原子性问题，就是要互斥，就是要保证中间状态对外不可见</li>
<li>锁是解决原子性问题的关键，明确知道我们锁的是什么，要保护的资源是什么，更重要的要知道你的锁能否保护这个受保护的资源(图中的箭头指向)</li>
<li>有效的临界区是一个入口和一个出口，多个临界区保护一个资源，也就是一个资源有多个并行的入口和多个出口，这就没有起到互斥的保护作用，临界区形同虚设</li>
<li>锁自己家门能保护资源就没必要锁整个小区，如果锁了整个小区，这严重影响其他业主的活动(锁粒度的问题)</li>
</ol>
<p>本文以 synchronized 锁举例来说明如何解决原子性问题，主要是帮助大家建立宏观的理念，用于解决原子性问题，这样后续你看到无论什么锁，只要脑海中回想起本节说明的模型，你会发现都是换汤不换药，学习起来就非常轻松了.</p>
<p>到这里并发的三大问题 有序性，可见性，原子性都有了解决方案，这是远看并发，让大家有了宏观的概念；但面试和实战都是讲求细节的，接下来我们由远及近，逐步看并发的细节，顺带说明那些面试官经常会问到的问题</p>
<h2 id="灵魂追问"><a href="#灵魂追问" class="headerlink" title="灵魂追问"></a>灵魂追问</h2><ol>
<li>多个锁锁一个资源一定会有问题吗？</li>
<li>什么时候需要锁小区，而不能锁某一户呢？</li>
<li>银行转账，两人互转和别人给自己转，用什么样的锁粒度合适呢？</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>面试volatile关键字时，我们应该具备哪些谈资？</title>
    <url>/2020/10/24/%E9%9D%A2%E8%AF%95volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E8%B0%88%E8%B5%84%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>在 <strong>可见性有序性，Happens-before来搞定</strong> 文章中，happens-before 的原则之一: volatile变量规则</p>
<blockquote>
<p>对一个 volatile 域的写, happens-before 于任意后续对这个 volatile 域的读</p>
</blockquote>
<p>按理说了解了这个规则，对 volatile 的使用就,,,,,,,,,已经足够了，但是面试官可是喜欢刨根问到底的，为了更透彻的了解 volatile 的内存语义与读写语义，为了面试多一些谈资进而获得一些加分项，同时尽早填补前序文章留下的坑，于是乎这篇文章就这样尴尬的诞生了</p>
<h2 id="happens-before-之-volatile-变量规则"><a href="#happens-before-之-volatile-变量规则" class="headerlink" title="happens-before 之 volatile 变量规则"></a>happens-before 之 volatile 变量规则</h2><p>下面的表格你还记得吗？(是的，你记得😂)</p>
<table>
<thead>
<tr>
<th>能否重排序</th>
<th>第二个操作</th>
<th>第二个操作</th>
<th>第二个操作</th>
</tr>
</thead>
<tbody><tr>
<td>第一个操作</td>
<td>普通读/写</td>
<td>volatile 读</td>
<td>volatile 写</td>
</tr>
<tr>
<td>普通读/写</td>
<td>-</td>
<td>-</td>
<td>NO</td>
</tr>
<tr>
<td>volatile 读</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>volatile 写</td>
<td>-</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<p>上面的表格是 JMM 针对编译器定制的 volatile 重排序的规则，那 JMM 是怎样禁止重排序的呢？答案是<strong>内存屏障</strong></p>
<h2 id="内存屏障-Memory-Barriers-Fences"><a href="#内存屏障-Memory-Barriers-Fences" class="headerlink" title="内存屏障 (Memory Barriers / Fences)"></a>内存屏障 (Memory Barriers / Fences)</h2><p>无论你听过这个名词与否都没关系，很简单，且看</p>
<blockquote>
<p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序</p>
</blockquote>
<p>这句话有点抽象，试着想象内存屏障是一面高墙，如果两个变量之间有这个屏障，那么他们就不能互换位置(重排序)了，变量有读(Load)有写(Store)，操作有前有后，JMM 就将内存屏障插入策略分为 4 种:</p>
<ol>
<li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障</li>
<li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障</li>
<li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障</li>
<li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障</li>
</ol>
<p>1 和 2 用图形描述以及对应表格规则就是下面这个样子了:<img src="/2020/10/24/%E9%9D%A2%E8%AF%95volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E8%B0%88%E8%B5%84%EF%BC%9F/202010245001.png" class=""></p>
<p>3 和 4 用图形描述以及对应表格规则就是下面这个样子了:</p>
<img src="/2020/10/24/%E9%9D%A2%E8%AF%95volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E8%B0%88%E8%B5%84%EF%BC%9F/202010245002.png" class="">

<blockquote>
<p>其实图形也是表格内容的体现，只不过告诉大家内存屏障是如何禁止指令重排序的，所以大家只要牢记表格内容即可</p>
</blockquote>
<p>一段程序的读写通常不会像上面两种情况这样简单，这些屏障组合起来如何使用呢？其实一点都不难，我们只需要将这些指令带入到文章开头的表格中，然后再按照程序顺序拼接指令就好了</p>
<p>来看一小段程序:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> v1 = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> v2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">readAndWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = v1; <span class="comment">//第一个volatile读</span></span><br><span class="line">		<span class="keyword">int</span> j = v2;	<span class="comment">//第二个volatile读</span></span><br><span class="line">		a = i + j;	<span class="comment">//普通写</span></span><br><span class="line">		v1 = i + <span class="number">1</span>;	<span class="comment">//第一个volatile写</span></span><br><span class="line">		v2 = j * <span class="number">2</span>;	<span class="comment">//第二个volatile写</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将屏障指令带入到程序就是这个样子:</p>
<img src="/2020/10/24/%E9%9D%A2%E8%AF%95volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E8%B0%88%E8%B5%84%EF%BC%9F/202010245003.png" class="">

<p>我们将上图分几个角度来看:</p>
<ol>
<li>彩色是将屏障指令带入到程序中生成的全部内容，也就是编译器生成的<strong>「最稳妥」</strong>的方案</li>
<li>显然有很多屏障是重复多余的，右侧虚线框指向的屏障是可以被<strong>「优化」</strong>删除掉的屏障</li>
</ol>
<p>到这里你应该了解了 volatile 是如何通过内存屏障保证程序不被”擅自”排序的，那 volatile 是如何保证可见性的呢？</p>
<h2 id="volatile-写-读的内存语义"><a href="#volatile-写-读的内存语义" class="headerlink" title="volatile 写-读的内存语义"></a>volatile 写-读的内存语义</h2><p>回顾一下之前文章内容中的程序，假定线程 A 先执行 writer 方法，随后线程 B 执行 reader 方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReorderExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		x = <span class="number">42</span>;	<span class="comment">//1</span></span><br><span class="line">		y = <span class="number">50</span>;	<span class="comment">//2</span></span><br><span class="line">		flag = <span class="keyword">true</span>;	<span class="comment">//3</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag)&#123;	<span class="comment">//4</span></span><br><span class="line">			System.out.println(<span class="string">&quot;x:&quot;</span> + x);	<span class="comment">//5</span></span><br><span class="line">			System.out.println(<span class="string">&quot;y:&quot;</span> + y);	<span class="comment">//6</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里你是否还记得之前说过的 JMM，是的，你还记得😂，当线程 A 执行 writer 方法时，且看下图:</p>
<img src="/2020/10/24/%E9%9D%A2%E8%AF%95volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E8%B0%88%E8%B5%84%EF%BC%9F/202010245004.png" class="">

<p>线程 A 将本地内存更改的变量写回到主内存中</p>
<blockquote>
<h3 id="volatile-读的内存语义"><a href="#volatile-读的内存语义" class="headerlink" title="volatile 读的内存语义:"></a>volatile 读的内存语义:</h3><p>当读一个 volatile 变量时, JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p>
</blockquote>
<p>所以当线程 B 执行 reader 方法时，图形结构就变成了这个样子:</p>
<img src="/2020/10/24/%E9%9D%A2%E8%AF%95volatile%E5%85%B3%E9%94%AE%E5%AD%97%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E5%85%B7%E5%A4%87%E5%93%AA%E4%BA%9B%E8%B0%88%E8%B5%84%EF%BC%9F/202010245005.png" class="">

<p>线程 B 本地内存变量无效，从主内存中读取变量到本地内存中，也就得到了线程 A 更改后的结果，这就是 volatile 是如何保证可见性的</p>
<p>如果你看过前面的文章你就不难理解上面的两张图了，综合起来说:</p>
<ol>
<li>线程 A 写一个volatile变量, 实质上是线程 A 向接下来将要读这个 volatile 变量的某个线程发出了(其对共享变量所做修改的)消息</li>
<li>线程 B 读一个 volatile 变量,实质上是线程 B 接收了之前某个线程发出的(在写这个 volatile 变量之前对共享变量所做修改的)消息。</li>
<li>线程 A 写一个 volatile 变量, 随后线程 B 读这个 volatile 变量, 这个过程实质上是线程 A 通过主内存向线程B 发送消息。</li>
</ol>
<p>到这里，面试 volatile 时，你应该有一些谈资了，同时也对 volatile 的语义有了更深层次的了解</p>
<h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><p>之前的文章提到过这样一句话:</p>
<blockquote>
<p>从内存语义的角度来说, volatile 的<code>写-读</code>与锁的<code>释放-获取</code>有相同的内存效果；volatile 写和锁的释放有相同的内存语义; volatile 读与锁的获取有相同的内存语义</p>
</blockquote>
<p>记住文中最后两张图， 当我们说到 synchronized 的时候，你就会猛的理解这句话的含义了, 感兴趣的可以自己先了解 synchronized 的写-读语义</p>
<p>接下来我们就聊一聊锁相关的内容了，敬请期待…</p>
<h2 id="灵魂追问"><a href="#灵魂追问" class="headerlink" title="灵魂追问"></a>灵魂追问</h2><ol>
<li>如果 volatile 写之后直接 return，那还会生成 StoreLoad 指令吗？</li>
<li>synchronized 是怎样逐步被优化的？</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka伪集群部署</title>
    <url>/2020/11/14/kafka%E4%BC%AA%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/kafka/2.6.0/kafka_2.12-2.6.0.tgz</span><br></pre></td></tr></table></figure>

<ol>
<li>执行解压命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf kafka_2.12-2.6.0.tgz -C /opt/kafka</span><br><span class="line">mv kafka_2.12-2.6.0 kafka</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>复制配置修改server1.properties配置</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/kafka/config</span><br><span class="line">cp config/server.properties config/server-1.properties</span><br><span class="line">cp config/server.properties config/server-2.properties</span><br><span class="line">cp config/server.properties config/server-3.properties</span><br></pre></td></tr></table></figure>

<blockquote>
<p>复制1的配置到2 3 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/kafka/data/kafka-logs-3</span><br><span class="line">mkdir -p /opt/kafka/data/kafka-logs-2</span><br><span class="line">mkdir -p /opt/kafka/data/kafka-logs-1</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li>修改 每个server 的配置文件  server-x.properties</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">server-1.properties</span></span><br><span class="line">broker.id=0</span><br><span class="line">listeners=PLAINTEXT://localhost:9092</span><br><span class="line">log.dirs=/opt/kafka/kafka-logs/kafka01</span><br><span class="line">zookeeper.connect=localhost:2181,localhost:2182,localhost:2183</span><br><span class="line"><span class="meta">#</span><span class="bash">server-2.properties</span></span><br><span class="line">broker.id=1</span><br><span class="line">listeners=PLAINTEXT://localhost:9093</span><br><span class="line">log.dirs=/opt/kafka/kafka-logs/kafka02</span><br><span class="line">zookeeper.connect=localhost:2181,localhost:2182,localhost:2183</span><br><span class="line"><span class="meta">#</span><span class="bash">server-3.properties</span></span><br><span class="line">broker.id=2</span><br><span class="line">listeners=PLAINTEXT://localhost:9094</span><br><span class="line">log.dirs=/opt/kafka/kafka-logs/kafka03</span><br><span class="line">zookeeper.connect=localhost:2181,localhost:2182,localhost:2183</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>启动集群及测试</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./kafka-server-start.sh -daemon ../config/server1.properties</span><br><span class="line">./kafka-server-start.sh -daemon ../config/server2.properties</span><br><span class="line">./kafka-server-start.sh -daemon ../config/server3.properties</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：如果单机伪集群内存不够，可以修改启动脚本，将红框内的内存改小些，默认为1G</p>
<p><code>vim ./bin/kafka-server-start.sh</code></p>
</blockquote>
<p><img src="data:image/png;base64,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" alt="img"></p>
<p>如果在启动中报错，kafka会在安装目录下生成一个错误log，可以通过查看该文件排错直至启动 </p>
<p><img src="data:image/png;base64,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" alt="img"></p>
<ol start="5">
<li>查看是否启动成功：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -nltp | grep 9092</span><br><span class="line">netstat -nltp | grep 9093</span><br><span class="line">netstat -nltp | grep 9094</span><br></pre></td></tr></table></figure>

<p>连接zookeeper测试</p>
<p><code>/usr/local/zookeeper/bin/zkCli.sh -server 127.0.0.1:2182,127.0.0.1:2183,127.0.0.1:2184</code> </p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx安装</title>
    <url>/2021/01/02/nginx%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
